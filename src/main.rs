use clap::{Arg, Command};
use classlink_checker::{LinkAnalyzer, UnifiedAnalyzer};
use serde_json;
use std::collections::HashSet;
use std::fs;
use std::path::Path;

fn main() {
    let matches = Command::new("classlink-checker")
        .version("0.2.0")
        .author("Generated by Claude")
        .about("Analyzes class links in Markdown, Python, TypeScript, and C# files")
        .arg(
            Arg::new("path")
                .help("Path to the directory or file to analyze")
                .required(true)
                .index(1),
        )
        .arg(
            Arg::new("output")
                .short('o')
                .long("output")
                .value_name("FORMAT")
                .help("Output format: text, json")
                .default_value("text"),
        )
        .arg(
            Arg::new("recursive")
                .short('r')
                .long("recursive")
                .help("Recursively scan subdirectories")
                .action(clap::ArgAction::SetTrue),
        )
        .get_matches();

    let path = matches.get_one::<String>("path").unwrap();
    let output_format = matches.get_one::<String>("output").unwrap();
    let recursive = matches.get_flag("recursive");

    match analyze_directory(path, recursive) {
        Ok(stats) => {
            match output_format.as_str() {
                "json" => {
                    match serde_json::to_string_pretty(&stats) {
                        Ok(json) => println!("{}", json),
                        Err(e) => eprintln!("Error serializing to JSON: {}", e),
                    }
                }
                "text" | _ => {
                    print_text_report(&stats);
                }
            }
        }
        Err(e) => {
            eprintln!("Error analyzing directory: {}", e);
            std::process::exit(1);
        }
    }
}

fn analyze_directory(path: &str, recursive: bool) -> Result<classlink_checker::LinkStatistics, Box<dyn std::error::Error>> {
    let unified_analyzer = UnifiedAnalyzer::new();
    let link_analyzer = LinkAnalyzer::new();
    
    let mut all_classes = HashSet::new();
    let mut all_links = Vec::new();
    
    let files = find_supported_files(path, recursive)?;
    
    for file_path in files {
        let content = fs::read_to_string(&file_path)?;
        let result = unified_analyzer.analyze_file(&content, &file_path);
        
        all_classes.extend(result.classes);
        all_links.extend(result.links);
    }
    
    Ok(link_analyzer.analyze(all_classes, all_links))
}

fn find_supported_files(path: &str, recursive: bool) -> Result<Vec<String>, Box<dyn std::error::Error>> {
    let mut files = Vec::new();
    let path = Path::new(path);
    let supported_extensions = ["md", "py", "ts", "tsx", "cs"];
    
    if path.is_file() {
        if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
            if supported_extensions.contains(&ext) {
                files.push(path.to_string_lossy().to_string());
            }
        }
    } else if path.is_dir() {
        for entry in fs::read_dir(path)? {
            let entry = entry?;
            let entry_path = entry.path();
            
            if entry_path.is_file() {
                if let Some(ext) = entry_path.extension().and_then(|e| e.to_str()) {
                    if supported_extensions.contains(&ext) {
                        files.push(entry_path.to_string_lossy().to_string());
                    }
                }
            } else if recursive && entry_path.is_dir() {
                let sub_files = find_supported_files(&entry_path.to_string_lossy(), recursive)?;
                files.extend(sub_files);
            }
        }
    }
    
    Ok(files)
}

fn print_text_report(stats: &classlink_checker::LinkStatistics) {
    print_header();
    print_overall_statistics(stats);
    print_isolated_classes(stats);
    print_class_link_counts(stats);
    print_most_significant_classes(stats);
}

fn print_header() {
    println!("=== Class Link Analysis Report ===\n");
}

fn print_overall_statistics(stats: &classlink_checker::LinkStatistics) {
    println!("üìä Overall Statistics:");
    println!("  Total Classes: {}", stats.total_classes);
    println!("  Isolated Classes: {}", stats.isolated_classes.len());
    println!();
}

fn print_isolated_classes(stats: &classlink_checker::LinkStatistics) {
    if !stats.isolated_classes.is_empty() {
        println!("üèùÔ∏è  Isolated Classes (no links):");
        for class in &stats.isolated_classes {
            println!("  - {}", class);
        }
        println!();
    }
}

fn print_class_link_counts(stats: &classlink_checker::LinkStatistics) {
    println!("üîó Class Link Counts:");
    let sorted_classes = get_sorted_classes_by_total_links(stats);
    
    for (class, counts) in sorted_classes {
        if has_any_links(counts) {
            println!("  üì¶ {}: {} outgoing, {} incoming", 
                     class, counts.outgoing_links, counts.incoming_links);
        }
    }
}

fn get_sorted_classes_by_total_links(stats: &classlink_checker::LinkStatistics) -> Vec<(&String, &classlink_checker::ClassLinkCount)> {
    let mut sorted_classes: Vec<_> = stats.class_link_counts.iter().collect();
    sorted_classes.sort_by(|a, b| {
        (b.1.outgoing_links + b.1.incoming_links).cmp(&(a.1.outgoing_links + a.1.incoming_links))
    });
    sorted_classes
}

fn has_any_links(counts: &classlink_checker::ClassLinkCount) -> bool {
    counts.outgoing_links > 0 || counts.incoming_links > 0
}

fn print_most_significant_classes(stats: &classlink_checker::LinkStatistics) {
    if let Some((class, count)) = &stats.most_linking_class {
        println!("\nüîù Most Linking Class: {} ({} outgoing links)", class, count);
    }
    
    if let Some((class, count)) = &stats.most_linked_class {
        println!("üéØ Most Linked Class: {} ({} incoming links)", class, count);
    }
}
